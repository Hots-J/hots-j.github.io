<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+Github搭建自己的博客(一)</title>
    <url>/posts/3e596dd.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
如果一件事情你不能讲清楚，十有八九你还没有完全理解
</blockquote>
<a id="more"></a>
<p>很早之前就想自己动手搭建一个博客，搭建一个属于自己的小天地，在这里可以写写心情，写写总结，也能写写自己在学习过程中碰见的坑与收获。在实验室折腾了两天，最终用Hexo+Github搭建完了博客，虽然过程十分简单，但是由于对于很多知识的不了解，还是碰见很多坑，折腾了好久。</p>
<h3 id="背景介绍">0. 背景介绍</h3>
<h4 id="什么是hexo">0.1 什么是Hexo</h4>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h4 id="什么是github">0.2 什么是Github</h4>
<p>Github是什么，是的，没错，世界最大的同性交友平台。2333......而我们写好的文章就可以部署在这个平台上。</p>
<p><img src="https://pic2.zhimg.com/80/7c9d3403bf922b1663f56975869c829b_hd.jpg" /></p>
<p>接下来便是安装、配置、美化、进阶的过程。</p>
<h3 id="环境的安装">1. 环境的安装</h3>
<h4 id="安装git">1.1 安装Git</h4>
<p>可以直接去官网下载，也可以直接点击这 <a href="https://gitforwindows.org/">Git</a> 一路next就可安装完毕，安装完成后，可以通过<code>git --version</code>来查看是否安装成功。</p>
<p><img src="https://i.loli.net/2019/10/19/hBsy2GLgRuVNc9r.png"  /></p>
<h4 id="安装node.js">1.2 安装Node.js</h4>
<p>可以直接去官网下载，也可以直接点击这 <a href="https://nodejs.org/en/download/">Node.js</a> 一路next就可安装完毕，安装完成后，可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>来查看是否安装成功。</p>
<p><img src="https://i.loli.net/2019/10/19/W3miTkNjJv6GAIl.png"  /></p>
<h4 id="安装hexo">1.3 安装Hexo</h4>
<p>先在任意路径创建一个空文件夹，在文件夹内，右击，选择<code>git bash here</code>，然后输入</p>
<p><code>npm install -g hexo-cil</code>安装完成后，可以通过<code>hexo -v</code>来查看是否安装成功。</p>
<p><img src="https://i.loli.net/2019/10/19/phdUTLr86l5W94N.png"  /></p>
<p>然后在bash里输入<code>hexo init myblog(任意名字)</code> 进入生成的这个文件夹，输入<code>npm install</code></p>
<p>就完成了环境的配置。此时本地的文件夹应该像这样（可能没有public文件夹）</p>
<p><img src="https://i.loli.net/2019/10/19/QfE6qb3d912PDCL.png" style="zoom:;" /></p>
<h3 id="部署到github">2. 部署到Github</h3>
<h5 id="创建github账号这个自己创一下就好">2.1 创建github账号，这个自己创一下就好。</h5>
<h5 id="创建一个-repository-仓库名称必须为-你的github的用户名.github.io">2.2 创建一个 repository， 仓库名称必须为 <strong>你的GitHub的用户名.github.io</strong></h5>
<h5 id="生成ssh">2.3 生成SSH</h5>
<p>任意位置右键打开git bash，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub的邮箱&quot;</span><br><span class="line">ssh-keygen -t rsa -C &quot;GitHub用户名&quot;</span><br></pre></td></tr></table></figure>
<p>然后一路回车，就创建好了SSH，此时终端上会显示存放SSH的路径，打开此路径，<strong>注意需要设置显示隐藏的文件才能看见.ssh文件夹</strong>。打开 id_rsa.pub ，复制其中的公共密钥。然后打开自己的github主页，点击自己头像下的setting，然后点击<code>new SSH key</code>，粘贴复制的密钥。</p>
<p><img src="https://i.loli.net/2019/10/19/DLYgURZdonw4Fm6.png"  /></p>
<p>完成后，在git bash中，输入<code>ssh -T git@github.com</code>，查看是否配置成功。成功后应该像这样。</p>
<p><img src="https://i.loli.net/2019/10/19/5LWYutIsUGbme9T.png"  /></p>
<p>但是我注意到终端反馈了一个问题，就是那个<code>The authenticity of ... can't be established</code>，随便百度了一波，发现没太大问题</p>
<p><img src="https://i.loli.net/2019/10/19/T7iEIdp3b9rCqxk.png"  /></p>
<h5 id="将hexo部署到github上">2.4 将Hexo部署到Github上</h5>
<p>打开初始化hexo后生成的那个文件夹，打开<code>_config.yml</code>配置文件，在这个文件中，找到，并设置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;GitHub的用户名&#x2F;GitHub的用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>然后右键 git bash输入 <code>npm install hexo-deployer-git --save</code>来安装部署的指令，安装完毕后，在当前文件夹内依次输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate &#x2F;&#x2F;(或输入hexo g)</span><br><span class="line">hexo deploy	  &#x2F;&#x2F;(或输入hexo d)</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>hexo clean</code>清除了你之前生成的东西。</li>
<li><code>hexo generate</code> 生成静态文章。</li>
<li><code>hexo deploy</code> 部署文章。</li>
</ul>
<p>在第一次执行<code>hexo deploy</code>时，会输入一次github的 username和password。</p>
<p>稍等片刻（大概1-2分钟），就能通过网址 <code>http://GitHub的用户名.github.io</code>访问你的博客啦。不出问题就像这样。</p>
<p><img src="https://i.loli.net/2019/10/19/TS8xLfcrqayJGp6.png"  /></p>
<p><strong>此时Hexo博客的搭建就基本完成了</strong>，这时可以有两种选择，一种是一直用那个github默认的网址去访问自己的博客，还有一种就是绑定自己的域名。</p>
<h4 id="绑定自己的域名">3. 绑定自己的域名</h4>
<h5 id="购买域名">3.1 购买域名</h5>
<p>我自己呢，就在阿里云上买了一个.top的域名（别问，问就是因为便宜...买了3年60多RMB）。在实名认证等一系列操作都弄完后，进入自己的域名控制台，然后点击操作下面的<strong>解析</strong>，然后点击<strong>添加记录</strong>，添加记录的配置如下</p>
<p><img src="https://i.loli.net/2019/10/19/EukCUvpty2TM6GW.png"  /></p>
<p><strong>注意：其中的记录值设置为自己github提供的访问博客的域名。</strong></p>
<p>然后在添加一条同样的记录，其中主机记录不填。最后的结果应该像这样。</p>
<p><img src="https://i.loli.net/2019/10/19/huHGNRX5439sKPO.png" /></p>
<p>然后进入github之前创建的那个存放博客的仓库，点击settings，设置Custom domain，输入自己的域名，点击<code>save</code>. 然后在你的博客文件夹的source中创建一个名为CNAME文件，不要后缀。写上你的域名。 最后在git bash中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate &#x2F;&#x2F;(或输入hexo g)</span><br><span class="line">hexo deploy	  &#x2F;&#x2F;(或输入hexo d)</span><br></pre></td></tr></table></figure>
<p>稍等片刻，就能通过自己的域名访问自己的博客了。奈斯！！！</p>
<p><strong>参考教程</strong></p>
<blockquote>
<p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建自己的博客(二)</title>
    <url>/posts/acd40dbf.html</url>
    <content><![CDATA[<h3 id="hexo主题的配置">1.Hexo主题的配置</h3>
<p>现在部署好自己的博客之后，接下来要做的就是通过配置文件来DIY自己的博客了。</p>
<p>以下配置均基于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NexT v7.4.2</span><br><span class="line">Hexo v4.0</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="更换主题">1.1 更换主题</h4>
<p>首先要做的就是更换自己喜欢的主题，默认的主题太难看了...Hexo配套的有大量的主题，点击这儿就能看到 <a href="https://hexo.io/themes/">主题</a>。我个人喜欢的是<a href="https://github.com/theme-next/hexo-theme-next">NexT主题</a>，去对应的github下载源文件，然后解压后，改一个简洁点的名字，把整个文件夹放到博客主文件夹的<code>themes</code>文件夹内（然后我就把原来的默认主题的文件夹顺手删了..）。然后打开主文件夹的<code>_config.yml</code>，找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>在<code>theme</code>后输如自己改之后的文件夹的名字，接着打开<code>themes\next\_config.yml</code>这个主题下的配置文件，找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>
<p>选择自己喜欢的主题的样式，各种不同的样式可以去hexo在github的主页上查看。</p>
<p>最后hexo三连一波</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>稍等片刻，就能看见自己修改之后的主题的样式了。我的就像这样。</p>
<p><img src="https://i.loli.net/2019/10/19/LebnPZjKqzNBk4E.png" style="zoom:80%;" /></p>
<h3 id="博客的进阶美化">2 博客的进阶美化</h3>
<h4 id="前置准备">2.1 前置准备</h4>
<p>由于博客内部的配置太多，每次配置完都要hexo三连上传到github上太麻烦了，所以可以使用<code>hexo serve</code></p>
<p><img src="https://i.loli.net/2019/10/20/XN5JQ3w9BsHtyVd.png" style="zoom:80%;" /></p>
<p>然后这时就可以通过网址<code>http://localhost:4000/</code>临时访问自己的博客了，而且此时在本地的所有修改与配置都能在这个网页上显现，因此只要在本地全部调试好后，在一次部署到github上。</p>
<h4 id="配置标题">2.2 配置标题</h4>
<p>打开根目录下的<code>_config.yml</code>，找到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: Jerome&#39;s Blog</span><br><span class="line">subtitle: 勿在浮沙筑高塔</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">author: Jerome</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure>
<p>在这里可以修改网址的标题和副标题，作者的名字，以及网站语言。其中<code>description</code> 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。（这里在后期配置SEO的时候再来配置）</p>
<h4 id="侧边栏社交小图标设置">2.3 侧边栏社交小图标设置</h4>
<p>打开<code>themes\next\_config.yml</code>这个主题下的配置文件，在<a href="https://fontawesome.com/icons?from=io">图标库</a>中找到自己喜欢的小图标，把名称复制到网页链接的<code>||</code>后面，由于知乎没有对应的图标，于是只显示默认的图标</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;hots-j || github</span><br><span class="line">  知乎: https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qian-qian-yang-guang-j&#x2F;activities</span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure>
<p>最后效果像这样</p>
<p><img src="https://i.loli.net/2019/10/20/L6qPoutgafFmJDr.png" /></p>
<h4 id="配置版权声明">2.4 配置版权声明</h4>
<p>在<code>themes\next\_config.yml</code>中找到并配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https:&#x2F;&#x2F;creativecommons.org</span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  language: en</span><br></pre></td></tr></table></figure>
<p>并在<code>\_config.yml</code>中添加自己的域名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;cjerome.top</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing index.html from permalinks</span><br></pre></td></tr></table></figure>
<h4 id="去掉底部的强力驱动和主题信息">2.5 去掉底部的强力驱动和主题信息</h4>
<p>在<code>themes\next\_config.yml</code>中找到并配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">powered:</span><br><span class="line">  # Hexo link (Powered by Hexo).</span><br><span class="line">  enable: false</span><br><span class="line">  # Version info of Hexo after Hexo link (vX.X.X).</span><br><span class="line">  version: true</span><br><span class="line"></span><br><span class="line">theme:</span><br><span class="line">  # Theme &amp; scheme info link (Theme - NexT.scheme).</span><br><span class="line">  enable: false</span><br><span class="line">  # Version info of NexT after scheme info (vX.X.X).</span><br><span class="line">  version: true</span><br></pre></td></tr></table></figure>
<h4 id="网站底部添加访客量">2.6 网站底部添加访客量</h4>
<p>在<code>themes\next\_config.yml</code>中找到并配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  # 总访问人数</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  # 总访问量</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  # 文章访问量</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/10/20/H3sTZIw56WOkjfX.png" /></p>
<p><strong>注意：</strong>因为此时是在本地服务上运行的结果，所以数据会异常，只要部署到github上就显示正常了。</p>
<h4 id="添加页面加载条">2.7 添加页面加载条</h4>
<p>然后在<code>themes\next\_config.yml</code>中修改配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  # Themes list:</span><br><span class="line">  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">  theme: minimal</span><br></pre></td></tr></table></figure>
<h4 id="添加作者头像">2.8 添加作者头像</h4>
<p>找到<code>\themes\next\source\images</code>文件夹，将自己的头像图片放在这个文件夹下，然后在<code>themes\next\_config.yml</code>中找到并配置为，即自己头像的路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar: &#x2F;images&#x2F;avatar.jpg</span><br></pre></td></tr></table></figure>
<h4 id="添加github-corners">2.9 添加GitHub Corners</h4>
<p>在<code>themes\next\_config.yml</code>中找到并配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># &#96;Follow me on GitHub&#96; banner in the top-right corner.</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https:&#x2F;&#x2F;github.com&#x2F;hots-j</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>
<p>最后就能显示啦，显示的效果为：</p>
<p><img src="https://i.loli.net/2019/10/20/PC3BxGJ9FSb4vUM.png" /></p>
<h4 id="添加本地搜索">2.10 添加本地搜索</h4>
<ul>
<li><code>npm install hexo-generator-searchdb --save</code></li>
<li>查找主题配置文件<code>themes/next/_config.yml</code>中的<code>local_search</code>配置为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<ul>
<li>在站点配置文件中添加</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br><span class="line">  format: html</span><br></pre></td></tr></table></figure>
<h4 id="优化底部标签样式">2.11 优化底部标签样式</h4>
<p>在主题配置文件<code>themes/next/_config.yml</code>中配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Use icon instead of the symbol # to indicate the tag at the bottom of the post</span><br><span class="line">tag_icon: true</span><br></pre></td></tr></table></figure>
<h4 id="添加评论模块">2.12 添加评论模块</h4>
<p>评论模块我选用的是 <a href="https://valine.js.org/">Valine</a></p>
<ul>
<li>获取APP ID 和 APP Key</li>
</ul>
<p>请先<a href="https://leancloud.cn/dashboard/login.html#/signin">登录</a>或<a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a> <code>LeanCloud</code>, 进入<a href="https://leancloud.cn/dashboard/applist.html#/apps">控制台</a>后点击左下角<a href="https://leancloud.cn/dashboard/applist.html#/newapp">创建应用</a>：</p>
<figure>
<img src="https://i.loli.net/2019/06/21/5d0c995c86fac81746.jpg" alt="img" /><figcaption>img</figcaption>
</figure>
<p>应用创建好以后，进入刚刚创建的应用，选择左下角的<code>设置</code>&gt;<code>应用Key</code>，然后就能看到你的<code>APP ID</code>和<code>APP Key</code>了：</p>
<figure>
<img src="https://i.loli.net/2019/06/21/5d0c997a60baa24436.jpg" alt="img" /><figcaption>img</figcaption>
</figure>
<ul>
<li><p>记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去</p></li>
<li><p>在主题配置文件<code>themes/next/_config.yml</code>中配置为</p></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># For more information: https://valine.js.org, https://github.com/xCss/Valine</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="comment"># Your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="comment"># Your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier. See: https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">hello</span> <span class="string">world</span> <span class="comment"># Comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># Language, available values: en, zh-cn</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#x27; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">false</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page</span></span><br><span class="line">  <span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Whether to record the commenter IP</span></span><br><span class="line">  <span class="attr">serverURLs:</span> <span class="comment"># When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span></span><br><span class="line">  <span class="comment">#post_meta_order: 0</span></span><br></pre></td></tr></table></figure>
<h4 id="添加分类和标签模块">2.13 添加分类和标签模块</h4>
<p>在博客的文件夹内：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<p>在主题配置文件<code>themes/next/_config.yml</code>中配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># External url should start with http:&#x2F;&#x2F; or https:&#x2F;&#x2F;</span><br><span class="line">menu:</span><br><span class="line">  home: &#x2F; || home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat</span><br></pre></td></tr></table></figure>
<p>创建成功，文件夹下会有个 categories.md，打开 index.md 文件并配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<p>创建成功，文件夹下会有个 tags.md，打开 index.md 文件并配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<p>其中<code>comments: false</code>是用来关闭当前页面的评论。</p>
<h4 id="添加字数统计">2.14 添加字数统计</h4>
<p><code>npm install hexo-symbols-count-time --save</code></p>
<p>在站点配置文件<code>_config.yml</code>中配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true                # 文章字数统计</span><br><span class="line">  time: true                   # 文章阅读时长</span><br><span class="line">  total_symbols: true          # 站点总字数统计</span><br><span class="line">  total_time: false             # 站点总阅读时长</span><br><span class="line">  exclude_codeblock: false     # 排除代码字数统计</span><br></pre></td></tr></table></figure>
<p>在主题配置文件<code>themes/next/_config.yml</code>中配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true     # 是否另起一行（true的话不和发表时间等同一行）</span><br><span class="line">  item_text_post: true     # 首页文章统计数量前是否显示文字描述（本文字数、阅读时长）</span><br><span class="line">  item_text_total: true   # 页面底部统计数量前是否显示文字描述（站点总字数、站点阅读时长）</span><br><span class="line">  awl: 4                   # Average Word Length</span><br><span class="line">  wpm: 275                 # Words Per Minute（每分钟阅读词数）</span><br><span class="line">  suffix: mins.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="侧边栏阅读进度">2.15 侧边栏阅读进度</h4>
<p>在主题配置文件<code>themes/next/_config.yml</code>中配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # 回页面顶部</span><br><span class="line">  sidebar: true</span><br><span class="line">  # 显示阅读百分比</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>
<h4 id="添加文章结束标识">2.16 添加文章结束标识</h4>
<ol type="1">
<li><p>在 <code>\在博客文件夹\source</code> 目录下，新建 <code>_data</code> 文件夹</p></li>
<li><p>进入 <code>_data</code> 文件夹，创建文件 <code>post-body-end.swig</code></p></li>
<li><p>编辑文件，添加如下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style&#x3D;&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">        -------------本文结束 &lt;i class&#x3D;&quot;fa fa-paw&quot;&gt;&lt;&#x2F;i&gt; 感谢您的阅读-------------</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>打开 <code>\themes\next\_config.yml</code></p></li>
<li><p>搜索 <strong>custom_file_path</strong> ，将如下内容取消注释</p></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">postBodyEnd: source&#x2F;_data&#x2F;post-body-end.swig</span><br></pre></td></tr></table></figure>
<h4 id="修改文章内链接样式">2.17 修改文章内链接样式</h4>
<p>找到<code>themes/next/source/css/_common/components/post/post.styl</code></p>
<p>在文件尾添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.post-body p a &#123;</span><br><span class="line">    color: #007ab2;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #007ab2;</span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">    color: #ff4f79;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #ff4f79;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修改底部年份和名称中间的图标">2.18 修改底部年份和名称中间的图标</h4>
<p>在主题配置文件<code>themes/next/_config.yml</code>中配置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  icon:</span><br><span class="line">    # 图标名称</span><br><span class="line">    name: heart</span><br><span class="line">    # 是否开启动画效果</span><br><span class="line">    animated: true</span><br><span class="line">    # 图标颜色</span><br><span class="line">    color: &quot;#ff4f79&quot;</span><br></pre></td></tr></table></figure>
<h4 id="添加live-2d模型">2.19 添加Live 2D模型</h4>
<p>首先<code>npm install --save hexo-helper-live2d</code></p>
<p>然后在站点配置文件<code>_config.yml</code>中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Live2D</span><br><span class="line">## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d</span><br><span class="line">## https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-init</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  # scriptFrom: local # 默认</span><br><span class="line">  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径</span><br><span class="line">  scriptFrom: jsdelivr # jsdelivr CDN</span><br><span class="line">  # scriptFrom: unpkg # unpkg CDN</span><br><span class="line">  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url</span><br><span class="line">  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false # 调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-hijiki</span><br><span class="line">    # use: live2d-widget-model-wanko</span><br><span class="line">    # npm-module package name</span><br><span class="line">    # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名</span><br><span class="line">    # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径</span><br><span class="line">    # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 145</span><br><span class="line">    height: 315</span><br><span class="line">  mobile:</span><br><span class="line">    show: false# 是否在移动设备上显示</span><br><span class="line">    scale: 0.5 # 移动设备上的缩放</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.8</span><br></pre></td></tr></table></figure>
<p>最后下载想要使用的模型</p>
<p><code>npm install live2d-widget-model-hijiki</code></p>
<p>所有模型的名称如下：模型的预览<a href="https://huaji8.top/post/live2d-plugin-2.0/">在这</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line">live2d-widget-model-haru&#x2F;01 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haru&#x2F;02 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-hijiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-nietzsche</span><br><span class="line">live2d-widget-model-nipsilon</span><br><span class="line">live2d-widget-model-nito</span><br><span class="line">live2d-widget-model-shizuku</span><br><span class="line">live2d-widget-model-tororo</span><br><span class="line">live2d-widget-model-tsumiki</span><br><span class="line">live2d-widget-model-unitychan</span><br><span class="line">live2d-widget-model-wanko</span><br><span class="line">live2d-widget-model-z16</span><br></pre></td></tr></table></figure>
<p>为了防止在手机端，模型会挡住文章，可以关闭mobile里的show。</p>
<h4 id="添加数学公式的支持">2.20 添加数学公式的支持</h4>
<p>首先在主题配置文件中，将配置选项打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Math Formulas Render Support</span><br><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax &#x2F; katex script on demand.</span><br><span class="line">  # That is it only render those page which has &#96;mathjax: true&#96; in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax &#x2F; katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https:&#x2F;&#x2F;mhchem.github.io&#x2F;MathJax-mhchem&#x2F;</span><br><span class="line">    mhchem: false</span><br></pre></td></tr></table></figure>
<p>然后安装 pandoc渲染器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm un hexo-renderer-marked</span><br><span class="line">$ npm i hexo-renderer-pandoc</span><br></pre></td></tr></table></figure>
<p>最后在每篇文章前需要加上，就可以愉快的显示公式了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章title</span><br><span class="line">mathjax: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h4 id="压缩静态页面提高网页加载速度">2.21 压缩静态页面，提高网页加载速度</h4>
<p>首先</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure>
<p>然后在站点配置文件中添加如下信息就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.css&#39;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.js&#39;</span><br><span class="line">    - &#39;**&#x2F;jquery.fancybox.pack.js&#39;</span><br><span class="line">    - &#39;**&#x2F;index.js&#39;</span><br></pre></td></tr></table></figure>
<h4 id="修改文章的链接地址">2.22 修改文章的链接地址</h4>
<p>Hexo文章的链接地址默认格式是<code>:year/:month/:day/:title/</code></p>
<p>如果文章的标题是中文的，那么链接就会出现一堆字符，从而可能引起各种问题，并且过长的文章链接也不利于百度蜘蛛的抓取。</p>
<p>首先安装 <code>npm install hexo-abbrlink --save</code></p>
<p>然后在站点配置文件<code>_config.yml</code>中修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line"># permalink_defaults:</span><br><span class="line">permalink: posts&#x2F;:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>
<p>最后hexo三连一波就OK啦！</p>
<p><strong>参考教程</strong></p>
<blockquote>
<p><a href="https://www.lnrcoder.cn/"><strong>学而不已</strong></a></p>
</blockquote>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现二分搜索树</title>
    <url>/posts/2d27453e.html</url>
    <content><![CDATA[<h3 id="二分搜索树的定义">1. 二分搜索树的定义</h3>
<p>二分搜索树是一颗二叉树</p>
<p>二分搜索树每个节点的左子树的值都小于该节点的值，每个节点右子树的值都大于该节点的值</p>
<p>任意一个节点的每棵子树都满足二分搜索树的定义</p>
<a id="more"></a>
<p>对于这些分类问题，我们可以采用逻辑回归的模型来进行比较好的分类。那么原理是什么呢？</p>
<h3 id="二分搜索树的实现">2. 二分搜索树的实现</h3>
<h4 id="定义主类">2.1 定义主类</h4>
<p>这里的二分搜索树支持泛型，由于需要比较节点的值，所以需要泛型必须实现Comparable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义节点类">2.2 定义节点类</h4>
<p>用于存储节点的值和左右子节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> E e;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">        left = <span class="keyword">null</span>;</span><br><span class="line">        right = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员变量和构造函数">2.3 成员变量和构造函数</h4>
<p>二分搜索树只需两个成员变量，根节点root和树中存储元素的数目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinarySearchTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    root = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="简单基础方法">2.4 简单基础方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="增加元素和查找元素">2.5 增加元素和查找元素</h4>
<p>增加元素的逻辑是，如果当前节点为<code>null</code>，则以增加的<code>val</code>去<code>new</code>一个新节点，并且维护一下<code>size</code></p>
<p>如果当前存在节点，那么判断当前节点的值和增加元素的值的大小，如果小于当前节点，则递归到当前节点的左孩子，递归调用增加函数，大于当前节点，同理。</p>
<p>查找元素和增加元素也同理，当找到当前节点为<code>null</code>时，则说明树中不存在要找的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    root = add(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回插入新元素e后的二分搜索树的根，递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">add</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = add(node.left, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = add(node.right, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> contains(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以node的为根的二分搜索树中是否包含元素e，递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e.equals(node.e)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> contains(node.left, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> contains(node.right, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历二分搜索树">2.6 遍历二分搜索树</h4>
<p>遍历分为递归实现和非递归实现，非递归实现时，需要借助辅助数据结构栈</p>
<p>层序遍历需要借助队列来实现</p>
<p>输出当前节点的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 前序遍历以node为根的二分搜索树，递归实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//访问该结点</span></span><br><span class="line">    System.out.println(node.e);</span><br><span class="line"></span><br><span class="line">    preOrder(node.left);</span><br><span class="line">    preOrder(node.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索树的前序遍历，非递归实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderNR</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分搜索树的层序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node cur = queue.remove();</span><br><span class="line">        System.out.println(cur.e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最值相关操作">2.7 最值相关操作</h4>
<p>查找最小值，由二分搜索树的性质可知，只需不停的递归遍历二分搜索树的左子树，如果当前节点的左子树存在，递归查找，直到左子树不存在时，那么当前节点的值就是整棵树中节点最小的值</p>
<p>查找最大值同理，只需递归查找右子树即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找二分搜索树中元素的最小值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;BST is empty!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">minimum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minimum(node.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 寻找二分搜索树中元素的最大值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;BST is empty!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(root).e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">maximum</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum(node.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除一个节点">2.8 删除一个节点</h4>
<p>删除节点是二分搜索树中最复杂的操作</p>
<p>删除节点分三种情况分析</p>
<ul>
<li>删除树中的最小值的节点</li>
<li>删除树中的最大值的节点</li>
<li>删除树中的指定值的节点</li>
</ul>
<h5 id="删除树中的最小值的节点">2.8.1 删除树中的最小值的节点</h5>
<p>首先通过上面写过的minimum()方法得到要删除节点的值</p>
<p>然后递归找到最左边的节点，如果该结点存在右子树，则将该右子树的根节点接上当前删除节点的父节点</p>
<p>即<code>node.left = 返回的右子树的根节点</code>，此时的node是递归返回到上一层的node，也就是删除节点的父节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除二分搜索树中的最小值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E ret = minimum();</span><br><span class="line">    root = removeMin(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node rightNode = node.right;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.left = removeMin(node.left);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除树中的最大值的节点">2.8.2 删除树中的最大值的节点</h5>
<p>与删除最小值同理，将删除节点的左子树挂接到删除节点的父节点上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除二分搜索树中的最大值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E ret = maximum();</span><br><span class="line">    root = removeMax(root);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">removeMax</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node leftNode = node.left;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.right = removeMax(node.right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="删除树中指定值的节点">2.8.3 删除树中指定值的节点</h5>
<p>删除指定值，首先要找到递归找到指定值，找到该节点后，又要分三种情况，分别是</p>
<ul>
<li>待删除节点的左子树为空</li>
<li>待删除节点的右子树为空</li>
<li>待删除节点的左右子树都不为空</li>
</ul>
<p>如果待删除节点的左子树为空，那么删除的过程就如同删除最小值的节点，即挂接该节点的右子树</p>
<p>如果待删除节点的右子树为空，那么删除的过程就如同删除最大值的节点，即挂接该节点的左子树</p>
<p>如果待删除节点的左右子树都不为空，那么根据二分搜索树的性质，我们需要找到待删除节点的右子树中的最小节点，用这个节点来顶替要删除的节点的位置，也就是把这个节点挂接到删除节点的父节点上。</p>
<p>其中待删除节点的右子树中的最小节点，我们可以通过上面写过的minimum()方法找到，找到后称该节点为后继节点，那么后继节点的左子树就应该是待删除节点的左子树，后继节点的右子树就应该是，待删除节点的右子树中删除后继节点后的子树，可以通过上面写过的removeMin()方法实现。最后就return 后继节点挂接到删除节点的父节点上就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除二分搜索树中元素为e的节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    root = remove(root, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">remove</span><span class="params">(Node node, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e.compareTo(node.e) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.left = remove(node.left, e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.compareTo(node.e) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        node.right = remove(node.right, e);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除节点左子树为空</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除节点右子树为空</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除节点左右都不为空</span></span><br><span class="line">        <span class="comment">//找到待删除节点的右子树中的最小节点，用这个节点来顶替要删除的节点的位置</span></span><br><span class="line">        Node successor = minimum(node.right);</span><br><span class="line">        successor.right = removeMin(node.right);</span><br><span class="line">        successor.left = node.left;</span><br><span class="line">        node.right = <span class="keyword">null</span>;</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分搜索树的存在的问题">3. 二分搜索树的存在的问题</h3>
<p>本次实现的这棵二分搜索树在极端情况下会退化成一条链表，如数据是<code>[1,2,3,4,5,6]</code>，此时就失去了二分查找的特性</p>
<p>对此我们可以将这棵二叉树维护成平衡二叉树，从而避免这种极端情况。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二分搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 131. 分割回文串</title>
    <url>/posts/eeb65480.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="思路">3. 思路</h3>
<p>对于每一个字符串，我们都有如下切分方法</p>
<p>如&quot;aab&quot;，可以切分为&quot;a&quot;, &quot;ab&quot;, &quot;aab&quot;</p>
<p>如&quot;abacdc&quot;，可以切分为&quot;a&quot;, &quot;ab&quot;, &quot;aba&quot;, &quot;abac&quot;, &quot;abacd&quot;, &quot;abacdc&quot;</p>
<p>在每次切完后，我们可以先判断当前切分出来的字符串是否为回文串，如果是，那么我们可以对于剩下的字符串继续进行这种切分，如果不是，那么就继续下一种切分情况</p>
<p>对于对剩下的字符串继续这种切分，可以通过递归实现。</p>
<p>当切完最后一个字符时，表示当前字符串切分情况以已经遍历完毕，将当前满足回文的List加入到结果list中</p>
<p>图示如下：</p>
<p><img src="https://pic.leetcode-cn.com/298a80282ac3505fec3710abdc1e656c591cf7acaa3ba976151480729244b649-image.png" /></p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前子串是否为回文串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(start) != s.charAt(end)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;String&gt; temp)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//已经切分到结尾</span></span><br><span class="line">        <span class="keyword">if</span>(end &gt;= s.length()) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;String&gt;(temp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//遍历一个字符串所有的切分情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = end; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String str = s.substring(start,i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//满足回文串，加入到list中</span></span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, start, i)) &#123;</span><br><span class="line">                temp.add(str);</span><br><span class="line">                <span class="comment">//对剩下的子串继续切分</span></span><br><span class="line">                dfs(s, i + <span class="number">1</span>,i + <span class="number">1</span>, temp);</span><br><span class="line">                <span class="comment">//当前情况遍历完毕，回溯</span></span><br><span class="line">                temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>, temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 116. 填充每个节点的下一个右侧节点指针</title>
    <url>/posts/33b5a27e.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>示例：</p>
<p><img src="https://i.loli.net/2020/09/22/giVD6jMItQrNSmq.png" /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>你只能使用常量级额外空间。 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</p>
<h3 id="思路i">3. 思路I</h3>
<p>我们可以通过递归实现，即对于传过来的节点node，我们只要将<code>node.left.next == node.right</code>，但是对于跨父节点的两个相邻节点，只传一个node节点不够，因为在传入一个node的兄弟节点，因此对于跨父节点的相邻节点就是<code>node1.left.next = node2.right</code></p>
<h3 id="代码实现i">4. 代码实现I</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectRight</span><span class="params">(Node leftNode, Node rightNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="keyword">null</span> &amp;&amp; rightNode == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//next指针指向右兄弟节点</span></span><br><span class="line">        leftNode.next = rightNode;</span><br><span class="line">        <span class="comment">//左子树的兄弟节点</span></span><br><span class="line">        connectRight(leftNode.left, leftNode.right);</span><br><span class="line">        <span class="comment">//右子树的兄弟节点</span></span><br><span class="line">        connectRight(rightNode.left, rightNode.right);</span><br><span class="line">        <span class="comment">//非同一个父节点的右节点和相邻左节点</span></span><br><span class="line">        connectRight(leftNode.right, rightNode.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        connectRight(root.left, root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路ii">5. 思路II</h3>
<p>也可以通过非递归来实现</p>
<p>对于有共同父节点的两个相邻节点，通过父节点就可以将这两个子节点串联起来</p>
<p>对于跨父节点的两个相邻节点，可以通过父节点的next找到邻居，然后要传联的就是next的左节点，即<code>root.right.next = root.next.left</code>，此时需要保证root.next不为空</p>
<p>核心就是这是一颗完美二叉树，且通过next指针将当前层连接起来，所以可以直接层序遍历</p>
<h3 id="代码实现ii">6. 代码实现II</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        Node pre = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pre.left为空时，没有下一层了，此时的Pre为叶子节点</span></span><br><span class="line">        <span class="keyword">while</span> (pre.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node tmp = pre;</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将tmp的左右节点都串联起来</span></span><br><span class="line">                <span class="comment">//同一个父节点的串联</span></span><br><span class="line">                tmp.left.next = tmp.right;</span><br><span class="line">                <span class="comment">//下一个不为空说明上一层已经帮我们完成串联了</span></span><br><span class="line">                <span class="keyword">if</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tmp.right.next = tmp.next.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//继续往右边遍历</span></span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从下一层的最左边开始遍历</span></span><br><span class="line">            pre = pre.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 17. 电话号码的字母组合</title>
    <url>/posts/39fb19.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" /></p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>
<p>说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p>
<h3 id="思路">3. 思路</h3>
<p>这道题可以通过回溯法暴力遍历每个数字对应的所有字母的所有组合情况</p>
<p>首先需要定义一个数字和字母对应的映射表，通过数字可以得到对应的字母串，然后遍历串里的每一个字符</p>
<p>维护一个字符串str，用来拼接每次访问到的字符，当str的长度等于包含数字字符串的长度时，表示已经得到一个解，add到结果列表中。然后返回出来，相当于回溯，继续遍历下一种情况。</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//结果列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//数字和字母映射表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String digits, <span class="keyword">int</span> index, String str)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//得到一种解</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == digits.length()) &#123;</span><br><span class="line">            ans.add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到当前数字</span></span><br><span class="line">        <span class="keyword">char</span> c = digits.charAt(index);</span><br><span class="line">        <span class="comment">//获取数字对应的字母串</span></span><br><span class="line">        String s = map.get(c);</span><br><span class="line">        <span class="comment">//遍历字母串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">//str加上当前字符，递归到下一个数字</span></span><br><span class="line">            dfs(digits, index + <span class="number">1</span>, str + ch);</span><br><span class="line">            <span class="comment">//递归结束返回，继续循环，遍历该串的下一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        dfs(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 200. 岛屿数量</title>
    <url>/posts/339fd01a.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;1&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;0&#39;,&#39;0&#39;],</span><br><span class="line">[&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;1&#39;,&#39;1&#39;]</span><br><span class="line">]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和&#x2F;或竖直方向上相邻的陆地连接而成。</span><br></pre></td></tr></table></figure>
<h3 id="思路">3. 思路</h3>
<p>遍历整个二维数组，如果当前是岛屿，则数量加1，并且标注当前位置已经访问过，然后遍历当前位置的上下左右四个方向，判断坐标是否在合法的范围，判断是否也还存在岛屿，判断存在的岛屿是否为还没被访问过的，如果都是，则将其位置标注为已访问，接着遍历在这个位置的上下左右四个方向，直到当前连通的所有岛屿已经全部访问完。然后找下一个存在的岛屿，重复以上过程</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] d = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//判断上下左右方向的坐标是否合法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//遍历所有的连通的岛屿</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//标记为已访问，下次不在访问</span></span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//遍历四个方向</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newx = x + d[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> newy = y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(isValid(newx, newy) &amp;&amp; !visited[newx][newy] &amp;&amp; grid[newx][newy] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dfs(grid, newx, newy);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历整个二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i][j] &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 47. 全排列II</title>
    <url>/posts/c66c6402.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="思路">3. 思路</h3>
<p>这道题的难点在于序列中包含了重复序列。如果使用Set，在最后生成结果时去重，那么会很耗时</p>
<p>所谓去重，就是指使用过的元素不能重复选取</p>
<p>对于使用过的元素，在树形结构上有两个维度，一个维度是同一树枝上使用过，一个维度是同一树层使用过</p>
<p>首先把示例中的[1,1,2]，抽象成一棵树，然后对在同一树层对使用过的元素去重</p>
<p><img src="https://pic.leetcode-cn.com/1600397590-keFZFY-47.%E5%85%A8%E6%8E%92%E5%88%97II1.png" /></p>
<p>图中我们对同一树层，前一位（也就是nums[i-1]）如果使用过，那么就进行去重。</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> index, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找到了一组解，记录下来</span></span><br><span class="line">        <span class="keyword">if</span>(index == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//对同一树层进行去重，注意，此时不难发现，由于此时前一层所有情况已经全部遍历完毕。所以对于</span></span><br><span class="line">            <span class="comment">//前一层使用过的状态应该为false，即 nums[i - 1] == false 时表示前一层使用过</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; nums[i - <span class="number">1</span>] == <span class="keyword">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(visited[i] != <span class="keyword">true</span>) &#123;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                dfs(nums, visited, index + <span class="number">1</span>, list);</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                visited[i] = <span class="keyword">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        dfs(nums, visited, <span class="number">0</span>, list);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 560. 和为K的子数组</title>
    <url>/posts/5c7b75ba.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">560. 和为K的子数组</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p>
<p>示例 1 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>
<p>说明 :</p>
<ul>
<li>数组的长度为 [1, 20,000]</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]</li>
</ul>
<h3 id="思路">3. 思路</h3>
<p>这道题可以通过前缀和的思路来做</p>
<p>即定义数组sum[i]代表数组nums[0...i]的和</p>
<p>我们就可以遍历一遍数组，得到所有的前缀和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum[i] &#x3D; sum[i - 1] + nums[i]</span><br></pre></td></tr></table></figure>
<p>对于任意一个区间[i, j]，若判断对于这个区间内的数组和是否为K，则可以转化为</p>
<p>也就是前 j 项和减去前 i - 1项和，得到的就是 i 到 j 的和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum[j] - sum[i - 1] &#x3D;&#x3D; k</span><br><span class="line">移项得</span><br><span class="line">sum[i - 1] &#x3D; sum[j] - k</span><br></pre></td></tr></table></figure>
<p>因此对于这道题，我们只要统计有多少个前缀和为 sum[j] - k 的个数即可</p>
<p>我们可以建立哈希表，存储sum[j]出现的频率，最后对于每个j，查看一下sum[j] - k 的次数，把次数累加起来，就是最终的结果。</p>
<p>由于我们只需要存储当前j下的sum[j]的频率，因此我们不需要单独开辟一个数组来存储前缀和，只要一个临时变量preSum即可</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储当前前缀和</span></span><br><span class="line">        <span class="keyword">int</span> preSum = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; fre = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        fre.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            preSum = preSum + nums[j];</span><br><span class="line">            <span class="comment">//判断当前的preSum-k是否存在</span></span><br><span class="line">            <span class="comment">//若preSum-k等于0，也属于1次，所以初始化时需要fre.put(0,1)</span></span><br><span class="line">            <span class="keyword">if</span>(fre.containsKey(preSum - k)) &#123;</span><br><span class="line">                cnt += fre.get(preSum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            fre.put(preSum, fre.getOrDefault(preSum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 538. 把二叉搜索树转换为累加树</title>
    <url>/posts/9b180ff8.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            &#x2F;   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            &#x2F;   \</span><br><span class="line">          20     13</span><br></pre></td></tr></table></figure>
<h3 id="思路">3. 思路</h3>
<p>对于二叉搜索树来说，对其中序遍历，即先访问左孩子、再访问根、再访问右孩子，这样得到的序列是一个升序的序列。那么如果对其反向中序遍历，即先访问右孩子、再访问根、再访问左孩子，就能得到从大到小的序列。最后在每次访问根节点时，累加就好了</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//反过来中序遍历</span></span><br><span class="line">        inOrder(node.right);</span><br><span class="line">        <span class="comment">//累加</span></span><br><span class="line">        node.val = node.val + sum;</span><br><span class="line">        sum = node.val;</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历的递归与非递归算法</title>
    <url>/posts/76bb7508.html</url>
    <content><![CDATA[<h3 id="递归遍历">1. 递归遍历</h3>
<p>对于二叉树的遍历，我们可以很轻易的写出其递归算法</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visit(root);</span><br><span class="line">        preorder(root.left);</span><br><span class="line">        preorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        visit(root);</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(root.left);</span><br><span class="line">        postOrder(root.right);</span><br><span class="line">        visit(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历">2. 非递归遍历</h3>
<p>但是对于二叉树的非递归遍历，我们则需要借助其他的数据结构，例如栈</p>
<h4 id="前序遍历">2.1 前序遍历</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// java中使用双向队列来代替Stack</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = stack.pop();</span><br><span class="line">            visit(cur);</span><br><span class="line">            <span class="comment">// 由于栈是先入后出，所以对于前序遍历，需要先将当前节点的右孩子压入栈</span></span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历">2.2 中序遍历</h4>
<p>先扫描（并非访问）根节点的所有左节点，并将其一一入栈。然后出栈一个节点，则访问它，然后扫描该节点的右孩子节点，将其进栈，在扫描该右孩子节点的所有左节点并一一入栈，如此继续</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;		<span class="comment">// 非空就一直往左子树走</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode cur = stack.pop();	<span class="comment">// 左子树走到头，访问根节点，遍历右子树</span></span><br><span class="line">                visit(cur);		<span class="comment">// 访问当前节点</span></span><br><span class="line">                root = cur.right;	<span class="comment">// 再往右子树走</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历">2.3 后序遍历</h4>
<p>先一直扫描所有左节点，直到左节点为空，然后出栈一个节点，即其左节点为空的根节点</p>
<p>判断当前根节点的右孩子是否为空，或者是已访问过的节点，若是则访问当前根节点，否则将根节点放回栈中，接着从根节点的右孩子节点开始，重复以上操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;	<span class="comment">// 一直扫描左孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            TreeNode cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (cur.right == <span class="keyword">null</span> || cur.right == prev) &#123;</span><br><span class="line">                visit(cur); 		<span class="comment">// 访问当前节点</span></span><br><span class="line">                prev = cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                root = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历">3. 层序遍历</h3>
<p>对于层序遍历，就是相当于广度优先搜索，因此需要借助队列来实现，把每一层遍历到的值存放在一个list中，最后将每层的list存放在最终的结果里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">	 	Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                temp.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 617. 合并二叉树</title>
    <url>/posts/113bbac.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p>注意: 合并必须从两个树的根节点开始。</p>
<h3 id="思路">3. 思路</h3>
<p>两个二叉树的对应节点可能存在以下三种情况</p>
<ul>
<li><p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p></li>
<li><p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p></li>
<li><p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和</p></li>
</ul>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 == <span class="keyword">null</span>) <span class="keyword">return</span> t2;</span><br><span class="line">        <span class="keyword">if</span>(t2 == <span class="keyword">null</span>) <span class="keyword">return</span> t1;</span><br><span class="line">        <span class="comment">//两个节点都不为空</span></span><br><span class="line">        TreeNode newNode = <span class="keyword">new</span> TreeNode(t1.val + t2.val);</span><br><span class="line">        <span class="comment">//同时遍历两棵树的左孩子</span></span><br><span class="line">        newNode.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">        <span class="comment">//同时遍历两棵树的右孩子</span></span><br><span class="line">        newNode.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>PCA的数学分析</title>
    <url>/posts/cb29d277.html</url>
    <content><![CDATA[<h3 id="什么是pca">1. 什么是PCA</h3>
<p><strong>PCA</strong>（Principal Component Analysis）是一种常用的数据分析方法。通过线性变换将原始数据变换为一组 各维度线性无关的数据，可用于提取数据的主要特征分量，常用于高维数据的降维。</p>
<a id="more"></a>
<p>在数据挖掘和机器学习中，数据常被表示为一组向量。</p>
<p>例如，2019年双十一的某家店铺的交易数据可以表示为一个向量，该列向量的格式为</p>
<p>(浏览量, 访客数, 下单数, 成交数, 成交金额)<sup>T</sup> 如(500, 240, 25, 20, 2312.15)<sup>T</sup></p>
<p>在这组数据中，我们可以看到浏览量和访客数，下单数和成交数都有着较强的相关关系。这种较强的相互关系可以理解为 “当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。</p>
<p>又因为机器学习算法的复杂度通常与数据的维数关系很密切，为了降低算法的复杂度，我们通常会对数据进行降维，虽然降维的结果会导致信息的丢失，但是由于某些维度之间存在着相互关系，因此我们可以将信息的损失尽量降低。</p>
<h3 id="向量相关">2. 向量相关</h3>
<h4 id="向量的内积">2.1 向量的内积</h4>
<p>两个维数相同的向量的内积被定义为： <span class="math display">\[
(a_1,a_2,...,a_n)^T\cdot(b_1,b_2,...,b_n)^T = a_1b_1+a_2b_2+...+a_nb_n
\]</span> 且内积运算将两个向量映射成了一个实数。</p>
<p>设A、B是两个n维向量，n维向量可以等价表示为n维空间中的一条从原点发射的有向线段。取 <span class="math display">\[
A = (x_1, y_1)\\
B = (x_2, y_2)
\]</span> 即其他维度的值都为0，从A点向B所在直线引一条垂线，垂线与B的交点叫做A在B上的投影，设A与B的夹角是a,则投影的矢量长度为 <span class="math inline">\(|A|cos(a)\)</span>，其中<span class="math inline">\(|A|=\sqrt{(x^2 _1+y^2 _1)}\)</span>，是向量A的模，即线段A的标量长度。</p>
<p><img src="https://i.loli.net/2019/11/02/CXKvAJQsZEF8YLN.png" style="zoom:80%;" /></p>
<p>又由内积公式的另一种形式： <span class="math display">\[
A\cdot B=|A||B|cos(a)
\]</span> 令<span class="math inline">\(|B| = 1\)</span>，则原式为： <span class="math display">\[
A\cdot B=|A|cos(a)
\]</span> <strong>那么可以得到，设向量B的模为1，则A与B的内积值等于A向B所在直线投影的矢量长度。</strong></p>
<h4 id="向量的基">2.2 向量的基</h4>
<p>要准确描述一个向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值。上述的向量均是默认在二维笛卡尔直角坐标系中，此时向量的基为(1,0), (0,1)。那么一个向量(x,y)实际上就是 <span class="math inline">\(x(1,0)^T +y(0,1)^T\)</span></p>
<p><img src="https://i.loli.net/2019/11/02/vrQULDtTyBgxJl2.png" style="zoom:80%;" /></p>
<p>那么，如果我们换一个基呢？例如，(1,1)和(-1,1)也可以成为一组基。那么我们首先要对基进行标准化，即，使其的模为1。标准化后的基为<span class="math inline">\((\frac{1}{\sqrt{2}} , \frac{1}{\sqrt{2}})\)</span>和<span class="math inline">\((- \frac{1}{\sqrt{2}}, \frac{1}{\sqrt{2}})\)</span></p>
<p>那么在笛卡尔坐标系中的向量(3,2)在新的基中的坐标就为<span class="math inline">\((\frac{5}{\sqrt{2}},- \frac{1}{\sqrt{2}})\)</span>，因为向量A在B上的投影为A与B的内积，那么向量在基上的投影也就为向量与基的内积，故变换过程为： <span class="math display">\[
\begin{pmatrix} \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}\\
-\frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}} \end{pmatrix}
\begin{pmatrix} 3\\ 2 \end{pmatrix}=
\begin{pmatrix} \frac{5}{\sqrt{2}}\\ -\frac{1}{\sqrt{2}} \end{pmatrix}
\]</span> 变换过程的图如下所示：</p>
<p><img src="https://i.loli.net/2019/11/02/CUYuqZSyJXkoKI6.png" style="zoom:80%;" /></p>
<p>这种变换可以进行推广，如果有<strong>M个N维向量</strong>，想将其变换为由<strong>R个N维向量</strong>表示的新空间中，那么首先将R个基按行组成矩阵A，然后将向量按列组成矩阵B，那么两矩阵的乘积AB就是变换结果。</p>
<p>数学表示为： <span class="math display">\[
\left(\begin{array}{c}{p_{1}} \\ {p_{2}} \\ {\vdots} \\ {p_{R}}\end{array}\right)\left(\begin{array}{llll}{a_{1}} &amp; {a_{2}} &amp; {\cdots} &amp; {a_{M}}\end{array}\right)=\left(\begin{array}{cccc}{p_{1} a_{1}} &amp; {p_{1} a_{2}} &amp; {\cdots} &amp; {p_{1} a_{M}} \\ {p_{2} a_{1}} &amp; {p_{2} a_{2}} &amp; {\cdots} &amp; {p_{2} a_{M}} \\ {\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \\ {p_{R} a_{1}} &amp; {p_{R} a_{2}} &amp; {\cdots} &amp; {p_{R} a_{M}}\end{array}\right)
\]</span> 其中<span class="math inline">\(P_i\)</span>是一个行向量，表示第<span class="math inline">\(i\)</span>个基；<span class="math inline">\(a_j\)</span>是一个列向量，表示第<span class="math inline">\(j\)</span>个原始数据记录。</p>
<h3 id="降维的思路与预处理">3. 降维的思路与预处理</h3>
<p>那么我们回到降维，对于一组N维向量，现在要将其降到K维（K小于N），那么我们应该如何选择K个基来进行变换才能最大程度的保留原有的信息呢？</p>
<p>设一组数据由5条记录组成，描述为矩阵形式为： <span class="math display">\[
\begin{pmatrix} 1&amp;1&amp;2&amp;4&amp;2\\
1&amp;3&amp;3&amp;4&amp;4 \end{pmatrix}
\]</span> 其中每一列为一条数据记录，而一行为一个字段。为了后续处理方便，首先将每个字段内所有值都减去字段均值， 其结果是将每个字段的均值变为0。</p>
<p>预处理之后为： <span class="math display">\[
\begin{pmatrix} -1&amp;-1&amp;0&amp;2&amp;0\\
-2&amp;0&amp;0&amp;1&amp;1 \end{pmatrix}
\]</span> 在直角坐标系中绘制如下：</p>
<p><img src="http://blog.codinglabs.org/uploads/pictures/pca-tutorial/06.png" alt="img" style="zoom:80%;" /></p>
<p>对于这5个二维数据，我们需要降维至一维来表示这些数据，由上述基变换的思路可以知道，这个问题实际上是要在二维平面中选择一个方向，将所有数据都投影到这个方向所在直线上，用投影值表示原始记录。</p>
<p>那么该如何找到这个方向？不过我们知道的是对于在这个方向投影后的投影值，有两个具体目标：</p>
<ol type="1">
<li>首先我们希望投影后的投影值尽可能的分散。</li>
<li>其次我们希望投影后的投影值能尽可能表示更多的原始信息，即不希望它们之间存在（线性）相关性。</li>
</ol>
<h3 id="方差与协方差">4. 方差与协方差</h3>
<h4 id="方差">4.1 方差</h4>
<p>对于要求投影后投影值尽可能分散，而这种分散程度，可以用数学上的<strong>方差</strong>来表述。</p>
<p>一个字段的方差可以看做是每个元素与字段均值的差的平方和的均值，即： <span class="math display">\[
\operatorname{Var}(a)=\frac{1}{m} \sum_{i=1}^{m}\left(a_{i}-\mu\right)^{2}
\]</span> 因为在预处理中，已经将每个字段的均值转化为0了，因此原方差就可以表示为： <span class="math display">\[
\operatorname{Var}(a)=\frac{1}{m} \sum_{i=1}^{m}\left(a_{i}\right)^{2}
\]</span> 因此目标一问题就转化为：<strong>寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</strong></p>
<p><strong>注：</strong>对于样本方差的计算，如果要得到他的无偏估计，应该除以<span class="math inline">\(m-1\)</span>而不是<span class="math inline">\(m\)</span>，但是对于降维来说，我们只需要使其得到最大值，而不是准确的无偏估计，即当取最大值时跟要除的常数没有关系，故为了计算的方便，选择了除以<span class="math inline">\(m\)</span>.下面的协方差公式同样如此。</p>
<h4 id="协方差">4.2 协方差</h4>
<p>对于要求投影后的投影值不希望它们之间存在（线性）相关性。而这种相关性，可以用数学上的<strong>协方差</strong>来表述。</p>
<p>两个字段间的协方差的数学公式可以表示为： <span class="math display">\[
\operatorname{Cov}(a,b)=\frac{1}{m} \sum_{i=1}^{m}(a_{i}-a_{\mu})\cdot(b_{i}-b_{\mu})
\]</span> 由于字段均值均为0，协方差公式可以简化为： <span class="math display">\[
\operatorname{Cov}(a,b)=\frac{1}{m} \sum_{i=1}^{m}a_{i}\cdot b_{i}
\]</span> 即可以简洁的表示为两个字段的内积再除以元素数m。</p>
<p>当协方差为0时，表示两个字段完全不相关。为了让协方差为0，我们选择第二个基时只能在与第一个基正交的方向上选择。因此最终选择的两个方向一定是正交的。</p>
<p>因此降维的优化目标就转化为：<strong>将一组N维向量降为K维（K大于0，小于N ），其目标是选择K个单位（模为1）的正交基，使得原始数据变换到这组基上后，各字段两两间协方差为0，而字段的方差则尽可能大（在正交的约束下，取最大的K个方差）。</strong></p>
<h4 id="协方差矩阵">4.3 协方差矩阵</h4>
<p>由于字段内方差及字段间协方差有密切关系。因此，可将两者统一表示。</p>
<p>记<span class="math inline">\(m\)</span>个二维向量构成的矩阵为<span class="math inline">\(X\)</span>，则: <span class="math display">\[
X=
\begin{pmatrix} a_1&amp;a_2&amp;\cdots&amp;a_m\\
b_1&amp;b_2&amp;\cdots&amp;b_m \end{pmatrix}
\]</span> 用<span class="math inline">\(X\)</span>乘以<span class="math inline">\(X\)</span>的转置，并乘上系数<span class="math inline">\(\frac{1}{m}\)</span>，则可得到协方差矩阵： <span class="math display">\[
\frac{1}{m} X X^{\top}=\left(\begin{array}{cc}
{\frac{1}{m} \sum\limits_{i=1}^{m} a_{i}^{2}} &amp; {\frac{1}{m} \sum\limits_{i=1}^{m} a_{i} b_{i}} \\
{\frac{1}{m} \sum\limits_{i=1}^{m} a_{i} b_{i}} &amp; {\frac{1}{m} \sum\limits_{i=1}^{m} b_{i}^{2}}\end{array}\right)
\]</span> 在协方差矩阵中，<strong>矩阵对角线上的两个元素分别是两个字段的方差，而其它元素是a和b的协方差。</strong></p>
<h4 id="协方差矩阵对角化">4.4 协方差矩阵对角化</h4>
<p>有了协方差矩阵，我们的目标就变成了，使除对角线外的其他元素化为0，并且在对角线上将元素按大小从上到下排列。而且这个目标的结果，正好就是对协方差矩阵求对角化的结果。</p>
<p>设原始数据矩阵<span class="math inline">\(X\)</span>对应的协方差矩阵为<span class="math inline">\(C\)</span>，一组基按行组成的矩阵为<span class="math inline">\(P\)</span>，设<span class="math inline">\(Y=PX\)</span>，则<span class="math inline">\(Y\)</span>为<span class="math inline">\(X\)</span>对<span class="math inline">\(P\)</span>做基变换后的数据矩阵。设<span class="math inline">\(Y\)</span>的协方差矩阵为<span class="math inline">\(D\)</span>，那么<span class="math inline">\(D\)</span>与<span class="math inline">\(C\)</span>的关系为： <span class="math display">\[
\begin{equation}
\begin{aligned} D &amp;=\frac{1}{m} Y Y^{\top} \\ &amp;=\frac{1}{m}(P X)(P X)^{\top} \\ &amp;=\frac{1}{m} P X X^{\top} P^{\top} \\ &amp;=P\left(\frac{1}{m} X X^{\top}\right) P^{\top} \\ &amp;=P C P^{\top} \end{aligned}
\end{equation}
\]</span> 由上述关系可以看出，优化目标为：寻找一个矩阵<span class="math inline">\(P\)</span>，满足<span class="math inline">\(PCP^T\)</span>是一个对角矩阵，并且对角元素按从大到小依次排列，那么<span class="math inline">\(P\)</span>的前<span class="math inline">\(K\)</span>行就是要寻找的基，用<span class="math inline">\(P\)</span>的前<span class="math inline">\(K\)</span>行组成的矩阵乘以<span class="math inline">\(X\)</span>，就使得<span class="math inline">\(X\)</span>从N维降到了K维，并满足上述优化条件。</p>
<h4 id="实对称矩阵">4.5 实对称矩阵</h4>
<p>由上述分析可知，协方差矩阵<span class="math inline">\(C\)</span>是一个对称矩阵，在线性代数中，实对称矩阵有着以下性质：</p>
<ul>
<li>实对称矩阵不同特征值对应的特征向量必然正交。</li>
<li>设特征向量λ重数为r，则必然存在r个线性无关的特征向量对应于λ，因此可以将这r个特征向量单位正交化。</li>
</ul>
<p>由上面两条可知，一个n行n列的实对称矩阵一定可以找到n个单位正交特征向量，设这n个特征向量为<span class="math inline">\(e_1,e_2,\cdots,e_n\)</span>，我们将其按列组成矩阵： <span class="math display">\[
E = \begin{pmatrix} e_1&amp;e_2&amp;\cdots&amp;e_n
 \end{pmatrix}
\]</span> 则矩阵<span class="math inline">\(E\)</span>和协方差矩阵<span class="math inline">\(C\)</span>的关系为： <span class="math display">\[
\begin{equation}
E^{\top} C E=\Lambda=\left(\begin{array}{cccc}{\lambda_{1}} &amp; {} &amp; {} &amp; {} \\ {} &amp; {\lambda_{2}} &amp; {} &amp; {} \\ {} &amp; {} &amp; {\ddots} &amp; {} \\ {} &amp; {} &amp; {} &amp; {\lambda_{n}}\end{array}\right)
\end{equation}
\]</span> 其中<span class="math inline">\(\wedge\)</span>为对角矩阵， 其对角元素为各特征向量对应的特征值（可能有重复）。</p>
<p>因此，我们要找的矩阵<span class="math inline">\(P\)</span>： <span class="math display">\[
P=E^T
\]</span> <span class="math inline">\(P\)</span>是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是协方差矩阵<span class="math inline">\(C\)</span>的一个特征向量。如果设<span class="math inline">\(P\)</span>按照<span class="math inline">\(\wedge\)</span>中特征值从大到小，将特征向量从上到下排列，则用<span class="math inline">\(P\)</span>的前K行组成的矩阵乘以原始数据矩阵<span class="math inline">\(X\)</span>，就得到了我们需要的降维后的数据矩阵<span class="math inline">\(Y\)</span>。</p>
<h3 id="pca的算法步骤">5. PCA的算法步骤</h3>
<p>设有m条n维数据。</p>
<ol type="1">
<li>将原始数据按列组成n行m列矩阵<span class="math inline">\(X\)</span></li>
<li>将<span class="math inline">\(X\)</span>的每一行（代表一个属性字段）进行零均值化，即减去这一行的均值</li>
<li>求出协方差矩阵<span class="math inline">\(C=\frac{1}{m} X X^{\top}\)</span></li>
<li>求出协方差矩阵的特征值及对应的特征向量</li>
<li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵<span class="math inline">\(P\)</span></li>
<li><span class="math inline">\(Y=PX\)</span>即为降维到k维后的数据</li>
</ol>
<h3 id="pca降维的实例">6. PCA降维的实例</h3>
<p>以上文提到的 <span class="math display">\[
\begin{pmatrix} -1&amp;-1&amp;0&amp;2&amp;0\\
-2&amp;0&amp;0&amp;1&amp;1 \end{pmatrix}
\]</span> 为例，我们用PCA方法将这组二维数据其降到一维。</p>
<p>因为这个矩阵的每行已经是零均值，这里直接求协方差矩阵： <span class="math display">\[
C=\frac{1}{5}\begin{pmatrix} -1&amp;-1&amp;0&amp;2&amp;0\\
-2&amp;0&amp;0&amp;1&amp;1 \end{pmatrix}
\begin{pmatrix} -1&amp;-2\\-1&amp;0\\0&amp;0\\
2&amp;1\\0&amp;1 \end{pmatrix}=
\begin{pmatrix} \frac{6}{5}&amp;\frac{4}{5}\\
\frac{4}{5}&amp;\frac{6}{5} \end{pmatrix}
\]</span> 然后求其特征值和特征向量，求解后特征值为： <span class="math display">\[
\lambda_1=2,\lambda_2=\frac{2}{5}
\]</span> 其对应的特征向量分别是： <span class="math display">\[
c_1\begin{pmatrix} 1\\
1 \end{pmatrix},c_2\begin{pmatrix} -1\\
1 \end{pmatrix}
\]</span> 其中对应的特征向量分别是一个通解，<span class="math inline">\(c_1\)</span>和<span class="math inline">\(c_2\)</span>可取任意实数。那么标准化后的特征向量为： <span class="math display">\[
\begin{pmatrix} \frac{1}{\sqrt{2}}\\
-\frac{1}{\sqrt{2}} \end{pmatrix},
\begin{pmatrix} -\frac{1}{\sqrt{2}}\\
\frac{1}{\sqrt{2}} \end{pmatrix}
\]</span> 因此我们的矩阵<span class="math inline">\(P\)</span>为： <span class="math display">\[
\begin{pmatrix} \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}\\
 -\frac{1}{\sqrt{2}}&amp;
\frac{1}{\sqrt{2}} \end{pmatrix}
\]</span> 可以验证协方差矩阵C的对角化： <span class="math display">\[
PCP^T=\begin{pmatrix} \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}\\
 -\frac{1}{\sqrt{2}}&amp;
\frac{1}{\sqrt{2}} \end{pmatrix}\begin{pmatrix} \frac{6}{5}&amp;\frac{4}{5}\\
 \frac{4}{5}&amp;
\frac{6}{5} \end{pmatrix}\begin{pmatrix} \frac{1}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}}\\
 \frac{1}{\sqrt{2}}&amp;
\frac{1}{\sqrt{2}} \end{pmatrix}=\begin{pmatrix} 2&amp;0\\
 0&amp;\frac{2}{5} \end{pmatrix}
\]</span> 最后我们用P的第一行乘以数据矩阵，就得到了降维后的数据： <span class="math display">\[
Y=\begin{pmatrix} \frac{1}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}} \end{pmatrix}
\begin{pmatrix} -1&amp;-1&amp;0&amp;2&amp;0\\
-2&amp;0&amp;0&amp;1&amp;1 \end{pmatrix}=
\begin{pmatrix} -\frac{3}{\sqrt{2}}&amp;-\frac{1}{\sqrt{2}}&amp;0&amp;\frac{3}{\sqrt{2}}&amp;\frac{1}{\sqrt{2}}
\end{pmatrix}
\]</span> 降维投影结果如下图：</p>
<p><img src="https://i.loli.net/2019/11/04/D8lVLyTxPQ2k3am.png" style="zoom:80%;" /></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 7. 整数翻转</title>
    <url>/posts/419b1c83.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/reverse-integer/">7. 整数反转</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure>
<p>注意:</p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p>
<h3 id="思路">3. 思路</h3>
<ul>
<li>初始化反转后的整数res为0</li>
<li>记录temp=res * 10 + x % 10，此时temp即为遍历到当前位之前的反转整数（x % 10）是取x的最后一位数</li>
<li><p>然后比较temp/10与res是否相等，如果整数不溢出显然相等，否则说明反转后的整数溢出，直接返回0</p></li>
<li>如果相等，就将temp赋值给res，表示完成一次反转，最后x去掉最后已经反转的一位</li>
<li><p>最后循环直到x等于0</p></li>
</ul>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> temp = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">         <span class="keyword">if</span> (temp / <span class="number">10</span> != res)</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         res = temp;</span><br><span class="line">         x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行流程">5.运行流程</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">以x = <span class="number">123456</span> 为例</span><br><span class="line"></span><br><span class="line">x = <span class="number">123456</span> res = <span class="number">0</span>      temp = <span class="number">6</span></span><br><span class="line">x = <span class="number">12345</span>  res = <span class="number">6</span>      temp = <span class="number">65</span></span><br><span class="line">x = <span class="number">1234</span>   res = <span class="number">65</span>     temp = <span class="number">654</span></span><br><span class="line">x = <span class="number">123</span>    res = <span class="number">654</span>    temp = <span class="number">6543</span></span><br><span class="line">x = <span class="number">12</span>     res = <span class="number">6543</span>   temp = <span class="number">65432</span></span><br><span class="line">x = <span class="number">1</span>      res = <span class="number">65432</span>  temp = <span class="number">654321</span></span><br><span class="line">x = <span class="number">0</span>      res = <span class="number">654321</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 03. 数组中重复的数字</title>
    <url>/posts/4c81dda0.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">剑指 Offer 03. 数组中重复的数字</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br></pre></td></tr></table></figure>
<p>限制：</p>
<p>2 &lt;= n &lt;= 100000</p>
<h3 id="思路">3. 思路</h3>
<p>因为数字范围在0-n-1范围内，可以直接开一个长度为n的数组，以nums[i]的值为数组下标，对应的值为出现次数，遍历nums，如果次数大于2，就直接return当前的nums[i]</p>
<p>当前也可以直接用HashMap去实现，存储数字和频率这一Entry</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] fre = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fre[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(fre[nums[i]] &gt;= <span class="number">2</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 05. 替换空格</title>
    <url>/posts/7768bbe3.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">剑指 Offer 05. 替换空格</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>
<p>限制：</p>
<p>0 &lt;= s 的长度 &lt;= 10000</p>
<h3 id="思路">3. 思路</h3>
<p>直接string的库函数，一行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return s.replace(&quot; &quot;, &quot;%20&quot;);</span><br></pre></td></tr></table></figure>
<p>当然也可以遍历整个字符串，用StringBuilder进行拼接，遍历到空格的话，就append一个&quot;%20&quot;</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 04. 二维数组中的查找</title>
    <url>/posts/d2e54803.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p>限制：</p>
<p>0 &lt;= n &lt;= 1000</p>
<p>0 &lt;= m &lt;= 1000</p>
<h3 id="思路">3. 思路</h3>
<p>首先可以直接两个for循环遍历整个二维矩阵，判断是否存在该数，此时的复杂度为O(n*m)</p>
<p>观察整个二维数组排序的顺序，首先使用两个指针指向整个二维数组的最右上角的元素，然后开始判断最右上角的元素是否大于target，如果大于，则往左移动一位，如果小于target，则往下移动一位，若等于target就直接返回true，否则全部遍历完之后返回一个false</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rown = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> coln = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> right = coln - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &gt;= <span class="number">0</span> &amp;&amp; left &lt; rown) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[left][right] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[left][right] &gt; target) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 06. 从尾到头打印链表</title>
    <url>/posts/75109394.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指 Offer 06. 从尾到头打印链表</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>
<p>限制：</p>
<p>0 &lt;= 链表长度 &lt;= 10000</p>
<h3 id="思路">3. 思路</h3>
<p>首先将链表逆序</p>
<p>然后从新的头，即之前的链表尾遍历一遍并存入数组中</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//链表逆序</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">            cnt++;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历逆序后的链表存入数组中</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[cnt];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans[index++] = pre.val;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 09. 用两个栈实现队列</title>
    <url>/posts/96badc6d.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>1 &lt;= values &lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用</p>
<h3 id="思路">3. 思路</h3>
<p>维护两个堆栈stack1,stack2，添加元素时，首先add进stack1，此时判断stack2是否为空，如果为空，则将stack1中元素全部pop到stack2中，此时stack中pop出来的顺序即为队列的顺序，若不为空，则先暂存在stack1，每次离队后也要判断一下stack2是否为空，若为空且stack1不为空，就接着把stack1中元素全部pop到stack2中.</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.addFirst(value);</span><br><span class="line">        <span class="comment">//入队时判断</span></span><br><span class="line">        <span class="keyword">while</span>(stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.addFirst(stack1.removeFirst());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty()) &#123;</span><br><span class="line">            ret =  stack2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//离队后判断</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty() &amp;&amp; !stack1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack2.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!stack1.isEmpty()) &#123;</span><br><span class="line">                    stack2.addFirst(stack1.removeFirst());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 10-I. 斐波那契数列</title>
    <url>/posts/646bc0ca.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>0 &lt;= n &lt;= 100</p>
<h3 id="思路">3. 思路</h3>
<p>可以通过动态规划的思路来实现</p>
<p>并且由于当前值只跟前一个值和前前一个值相关，所以可以无需开辟dp数组，直接用两个变量来存储</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ppre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            cur = (pre + ppre) % (<span class="number">1000000007</span>);</span><br><span class="line">            ppre = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer 10-II. 青蛙跳台阶问题</title>
    <url>/posts/34501d57.html</url>
    <content><![CDATA[<h3 id="原题链接">1. 原题链接</h3>
<p><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></p>
<a id="more"></a>
<h3 id="题目描述">2. 题目描述</h3>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<p>0 &lt;= n &lt;= 100</p>
<h3 id="思路">3. 思路</h3>
<p>这道题也可以通过动态规划的思路来实现</p>
<p>这道题思路与上一道<a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/">剑指 Offer 10- I. 斐波那契数列</a>思路一模一样，这里用开dp数组的做法，也可以不开</p>
<p>dp[i]表示第i个台阶共有多少种跳法</p>
<h3 id="代码实现">4. 代码实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            dp[i] = dp[i] % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次小爬虫</title>
    <url>/posts/75177dc0.html</url>
    <content><![CDATA[<p>这天突然收到师兄发的消息，想让我帮他爬一次中国联通的历史股票数据</p>
<p>数据的链接在这 <a href="http://www.aigaogao.com/tools/history.html?s=600050">中国联通</a></p>
<a id="more"></a>
<p>打开F12可以看到网页内的数据是这样的</p>
<p><img src="https://i.loli.net/2020/09/27/FQ5xJLNSAR9BOjk.png" /></p>
<p>所以需要爬取的数据都在<code>&lt;tr&gt;</code>标签下的<code>&lt;td&gt;</code>标签内</p>
<p>首先我们要爬取整个页面，此时<code>response.text</code>即为爬取整个网页文本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://www.aigaogao.com/tools/history.html?s=600050&#x27;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">response.raise_for_status()<span class="comment"># 如果HTTP请求返回了不成功的状态码,会抛出一个HTTPError异常</span></span><br><span class="line">response.encoding = response.apparent_encoding <span class="comment"># 从内容中分析出的响应内容编码方式</span></span><br><span class="line"></span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>
<p>接下来我们需要找到对应的标签，此时用一个贼好用的库 <code>xpath</code></p>
<p>XPath，全称 XML Path Language，即 XML 路径语言，它是一门在 XML 文档中查找信息的语言。最初是用来搜寻 XML 文档的，但同样适用于 HTML 文档的搜索。所以在做爬虫时完全可以使用 XPath 做相应的信息抽取</p>
<p>XPath 的选择功能十分强大，它提供了非常简洁明了的路径选择表达式。另外，它还提供了超过 100 个内建函数，用于字符串、数值、时间的匹配以及节点、序列的处理等，几乎所有想要定位的节点都可以用 XPath 来选择。</p>
<p>这是官方文档 <a href="https://www.w3.org/TR/2017/REC-xpath-31-20170321/">xpath</a></p>
<p>首先先定位到所有标签最近的父标签，如图中的<code>&lt;div&gt;</code>，右键选择<code>copy XPath</code></p>
<p>得到此时的路径<code>//*[@id=&quot;ctl16_contentdiv&quot;]</code></p>
<p><img src="https://i.loli.net/2020/09/27/4v3RbdZXQaAzho1.png" /></p>
<h5 id="xpath-常用规则">XPath 常用规则</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">表达式</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">nodename</td>
<td style="text-align: left;">选取此节点的所有子节点</td>
</tr>
<tr class="even">
<td style="text-align: left;">/</td>
<td style="text-align: left;">从当前节点选区直接子节点</td>
</tr>
<tr class="odd">
<td style="text-align: left;">//</td>
<td style="text-align: left;">从当前节点选取子孙节点</td>
</tr>
<tr class="even">
<td style="text-align: left;">.</td>
<td style="text-align: left;">选取当前节点</td>
</tr>
<tr class="odd">
<td style="text-align: left;">..</td>
<td style="text-align: left;">选取当前节点的父节点</td>
</tr>
<tr class="even">
<td style="text-align: left;">@</td>
<td style="text-align: left;">选取属性</td>
</tr>
</tbody>
</table>
<p>*代表匹配所有节点，返回的结果是一个列表，每个元素都是一个 Element 类型，后跟节点名称。</p>
<p>/text() 文本获取，表示获取当前节点中的文本</p>
<p>因此</p>
<p>在当前路径下<code>//*[@id=&quot;ctl16_contentdiv&quot;]</code></p>
<p><code>/table/tr</code>表示div下面的tr节点</p>
<p><code>//*/text()</code>表示tr下面的所有节点的所有文本</p>
<p>即可获取想要爬取的所有信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">tree = etree.HTML(response.text)</span><br><span class="line">res = tree.xpath(<span class="string">&#x27; // *[ @ id = &quot;ctl16_contentdiv&quot;]/table/tr//*/text()&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>最后附上所有的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    url = <span class="string">&#x27;http://www.aigaogao.com/tools/history.html?s=600050&#x27;</span></span><br><span class="line"></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">    response.encoding = response.apparent_encoding</span><br><span class="line">    tree = etree.HTML(response.text)</span><br><span class="line">    res = tree.xpath(<span class="string">&#x27; // *[ @ id = &quot;ctl16_contentdiv&quot;]/table/tr//*/text()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    f = open(<span class="string">&#x27;test.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    csv_writer = csv.writer(f)</span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">in</span> [<span class="string">&#x27;缩&#x27;</span>, <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        list.append(item)</span><br><span class="line">        cnt = cnt + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="number">12</span>:</span><br><span class="line">            csv_writer.writerow(list)</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            list = []</span><br><span class="line"></span><br><span class="line">    f.close()</span><br><span class="line">    print(<span class="string">&quot;done&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>这是最后爬取的数据结果</p>
<p><img src="https://i.loli.net/2020/09/27/43YQ1bCqNjDfSWa.png" /></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/posts/f9b01ad8.html</url>
    <content><![CDATA[<h3 id="逻辑回归的应用">1. 逻辑回归的应用</h3>
<p>生活中的很多分类问题</p>
<ul>
<li>贷款违约情况（会违约/不会违约）</li>
<li>广告点击问题（会点击/不会点击）</li>
<li>商品推荐（会购买/不会购买）</li>
<li>情感分析（正面/负面）</li>
<li>疾病诊断（阳性/阴性）</li>
</ul>
<p>等等.....</p>
<a id="more"></a>
<p>对于这些分类问题，我们可以采用逻辑回归的模型来进行比较好的分类。那么原理是什么呢？</p>
<h3 id="逻辑回归的原理">2. 逻辑回归的原理</h3>
<p>下面给出一个具体的例子：</p>
<p><img src="https://i.loli.net/2020/01/10/F8azDLyptJNPiHh.png" /></p>
<p>对于这个分类任务，我通过学习已知的年龄、工资、学历情况和对应的是否逾期情况，来判断当年龄为27，工资为7000，学历为本科时，他逾期的概率是多少。本质上就是计算一个条件概率。而对于已知数据的学习，就是想使得对应的条件概率<code>P(Y|X)</code>越大越好。</p>
<p>重点是如何定义这个条件概率，如果直接用线性回归表示 <span class="math display">\[
P(Y|X;\omega)=\omega^Tx+b
\]</span></p>
<h4 id="逻辑函数">2.1逻辑函数</h4>
<p>那么计算出来的是一个实值，还是无法直接通过实值进行分类。因此考虑引入逻辑函数 <span class="math display">\[
y =\sigma(x)=\frac{1}{1+e^{-x}}
\]</span> 逻辑函数的图像如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7691426-17d142c9dab67649.png" /></p>
<p>此时将计算出来的值 <span class="math inline">\(z=\omega^Tx+b\)</span> 带入逻辑函数中就可以得到 <span class="math display">\[
y=
\begin{cases}
0&amp; \text{z&lt;0}\\
0.5&amp; \text{z=0}\\
1&amp; \text{z&gt;0}
\end{cases}
\]</span> 即z大于0就判为正例，小于0就判为反例，为临界值0则可以任意判断。</p>
<h4 id="目标函数">2.2 目标函数</h4>
<p>因此新的条件概率就定义为 <span class="math display">\[
P(Y|X;\omega)=\sigma(\omega^Tx+b)=\frac{1}{1+e^{-(\omega^Tx+b)}}
\]</span> 其中 <span class="math inline">\(\omega^T = (\omega_1, \omega_1,...,\omega_n)\)</span> ，n=特征数量。</p>
<p>对于上面那个具体的例子，可以列出 <span class="math display">\[
P(Y=Yes|X=(20,4000,本科))=\frac{1}{1+e^{-[{\begin{pmatrix}
\omega_1 \omega_2 \omega_3\\
\end{pmatrix}}{\begin{pmatrix}20\\4000\\本科\\
\end{pmatrix}}+b]}}
\\\ldots
\]</span> 通过已知数据计算出，令所有似然函数都最大的参数<span class="math inline">\(\omega^T\)</span>和<span class="math inline">\(b\)</span>，最后代入要预测的特征x，就能得到最终的分类y。</p>
<p>对于二分类的问题： <span class="math display">\[
P(Y=1|X;\omega)=\sigma(\omega^Tx+b)=\frac{1}{1+e^{-(\omega^Tx+b)}}\\
P(Y=0|X;\omega)=1-P(Y=1|X;\omega)=\frac{e^{-(\omega^Tx+b)}}{1+e^{-(\omega^Tx+b)}}
\]</span> 两个式子可以合并成 <span class="math display">\[
P(Y|X;\omega)=P(Y=1|X;\omega)^y[1-P(Y=1|X;\omega)]^{1-y}
\]</span> 那么接下来的问题就是，该如何计算出参数 <span class="math inline">\(\omega^T\)</span>和<span class="math inline">\(b\)</span> 呢？</p>
<h4 id="最大化目标函数">2.3 最大化目标函数</h4>
<p>我们要最大化目标函数，从而求出 <span class="math inline">\(\omega^T\)</span>和<span class="math inline">\(b\)</span> ，即 <span class="math display">\[
\hat{\omega},\hat{b}=argmax_{\omega,b}\prod_{i=1}^n p(y_i|x_i,w,b)
\]</span> 两边取对数 <span class="math display">\[
=argmax_{\omega,b}log(\prod_{i=1}^n p(y_i|x_i,w,b))\\
=argmax_{\omega,b}\sum_{i=1}^nlog( p(y_i|x_i,w,b))
\]</span> 取负号，即最小化目标函数 <span class="math display">\[
=argmin_{\omega,b}-\sum_{i=1}^nlog( p(y_i|x_i,w,b))\\
=argmin_{\omega,b}-\sum_{i=1}^nlog[p(y_i=1|x_i;\omega,b)^{y_i}[1-p(y_i=1|x_i;\omega,b]^{1-{y_i}}]\\
=argmin_{\omega,b}-\sum_{i=1}^n[y_ilog(p(y_i=1|x_i;\omega,b))+(1-y_i)log(1-p(y_i=1|x_i;\omega,b))]
\]</span> 接下来就是通过优化算法把目标函数的最优解计算出来。</p>
<p>如何寻找一个函数最大化或者最小化的最优解？</p>
<h4 id="优化算法">2.4 优化算法</h4>
<p>对于凸函数来说，对函数求出的最优解一般就算全局最优解。</p>
<p>对于非凸函数来说，求出的最优解一般是局部最优解，不一定是全局最优解。</p>
<p>该如何选择优化算法呢？</p>
<p>对于简单的函数，直接求导，令导数为0，就能把参数解出来。但是对于复杂的函数，无法直接求出参数，因此我们要采用数值优化的思路，通过循环迭代的方式找到最优的参数。</p>
<p>最常用的优化算法就是梯度下降法（ Gradient Descent ）</p>
<h3 id="梯度下降法">3. 梯度下降法</h3>
<p>求使得<span class="math inline">\(f(w)\)</span>值最小的参数<span class="math inline">\(w\)</span></p>
<p><img src="https://i.loli.net/2020/01/10/4pocyFSPRbMlBVN.png" /></p>
<p><span class="math inline">\(\eta\)</span>为学习率，也就是梯度下降的步长。</p>
<p>对于上面具体的例子，我们知道 <span class="math display">\[
P(y=1|x;\omega)=\sigma(\omega^Tx+b)=\frac{1}{1+e^{-(\omega^Tx+b)}}
\]</span> 以及目标函数 <span class="math display">\[
=argmin_{\omega,b}-\sum_{i=1}^n[y_ilog(p(y_i=1|x_i;\omega,b))+(1-y_i)log(1-p(y_i=1|x_i;\omega,b))]\\
=argmin_{\omega,b}-\sum_{i=1}^n[y_ilog(\sigma(\omega^Tx_i+b))+(1-y_i)log(1-\sigma(\omega^Tx_i+b))]
\]</span> 令 <span class="math display">\[
L(w,b)=-\sum_{i=1}^n[y_ilog(\sigma(\omega^Tx_i+b))+(1-y_i)log(1-\sigma(\omega^Tx_i+b))]
\]</span> 又 <span class="math display">\[
\frac{\partial \sigma(x)}{\partial x}=\sigma(x)\cdot[1-\sigma(x)]
\]</span> 则 <span class="math display">\[
\frac{\partial L(w,b)}{\partial w}=\sum_{i=1}^n[\sigma(\omega^Tx_i+b)-y_i]\cdot{x_i}
\]</span></p>
<p><span class="math display">\[
\frac{\partial L(w,b)}{\partial b}=\sum_{i=1}^n[\sigma(\omega^Tx_i+b)-y_i]
\]</span></p>
<p>观察求导后的式子，可以发现<span class="math inline">\(\sigma(\omega^Tx_i+b)\)</span>是当前的参数计算出的预测值，<span class="math inline">\(y_i\)</span>是真实值，所以就是通过当前的预测值与真实值的差来调整新的参数。</p>
<h4 id="梯度下降法的流程">3.1 梯度下降法的流程</h4>
<p>因此最终的梯度下降法的流程为</p>
<p><img src="https://i.loli.net/2020/01/10/ZcDiI8KamQG3S2P.png" /></p>
<h4 id="迭代的终止条件">3.2 迭代的终止条件</h4>
<p>有一个问题，这个循环的终止条件是什么？</p>
<ol type="1">
<li>计算目标函数<span class="math inline">\(L(w,b)\)</span>的值，如果变化幅度很小很小，就可以停止迭代了</li>
<li>计算<span class="math inline">\(|w^{t+1}-w^{t}|\)</span>，如果基本不变了，就可以停止</li>
<li>通过计算验证集的正确率</li>
<li>直接迭代1w次或者更多次，如果学习率设置合理，那么最终一定会收敛</li>
</ol>
<h3 id="题外话">4.题外话</h3>
<p>逻辑回归是线性分类器吗？如何判断一个分类器是不是线性分类器呢？</p>
<p>判断是不是线性分类器根本是判断模型的决策边界是不是线性的。</p>
<p>对于二分类的问题，我们知道决策边界有个性质，就是落在决策边界上的点被分成1或者0的概率是相等的。</p>
<p>因此可以得到决策边界的方程 <span class="math display">\[
\frac {P(Y=1|X;\omega)}{P(Y=0|X;\omega)}=1
\]</span> 化简为</p>
<p><span class="math display">\[
\frac{\frac{1}{1+e^{-(\omega^Tx+b)}}}{\frac{e^{-(\omega^Tx+b)}}{1+e^{-(\omega^Tx+b)}}}=1\\
e^{-(\omega^Tx+b)}=1
\]</span></p>
<p>即</p>
<p><span class="math display">\[
\omega^Tx+b=0
\]</span></p>
<p>因为决策边界是线性的，所以逻辑回归也是线性的分类器。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>逻辑回归</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC基础相关</title>
    <url>/posts/447c970d.html</url>
    <content><![CDATA[<h3 id="什么是spring-mvc">1. 什么是Spring MVC</h3>
<ul>
<li>Spring MVC是Spring体系的轻量级Web MVC框架</li>
<li>Spring MVC的核心是Controller控制器，用于处理请求，产生响应</li>
<li>Spring MVC基于Spring IOC容器运行，所有对象被IOC管理</li>
</ul>
<a id="more"></a>
<h3 id="springmvc环境配置">2. SpringMVC环境配置</h3>
<h4 id="maven配置依赖spring-webmvc">2.1 Maven配置依赖spring-webmvc</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="web.xml配置dispatcherservlet">2.2 web.xml配置DispatcherServlet</h4>
<p>DispatcherServlet 是Spring MVC最核心的对象，用于拦截http请求，并根据请求的url调用与之对应的Controller方法，来完成http请求的处理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--        在web应用启动时自动创建Spring IOC容器--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--        并初始化DispatcherServlet--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--        若不配置则会在第一次访问url时创建IOC容器--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &#x27;/&#x27;代表拦截所有请求--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置applicationcontext的mvc标记">2.3 配置applicationContext的mvc标记</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    开启com.imooc.springmvc包下所有子包的注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.imooc.springmvc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    启用SpringMVC的注解开发模式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    将图片/js/css等静态资源排除，提高执行效率--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="开发controller控制器">2.4 开发Controller控制器</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springmvc.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span> <span class="comment">//直接向响应输出字符串数据，不跳转页面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello mvc&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时运行tomcat，访问localhost:8080/test，就会显示<code>hello mvc</code></p>
<h3 id="springmvc流程图">3. SpringMVC流程图</h3>
<p><img src="https://i.loli.net/2020/09/22/gSpjYb9ytsendCK.png" /></p>
<h3 id="springmvc数据绑定">4. SpringMVC数据绑定</h3>
<h4 id="url-mapping">4.1 URL Mapping</h4>
<p>URL Mapping是将URL与Controller方法绑定</p>
<p>从而使得SpringMVC可通过Tomcat对外暴露服务</p>
<h4 id="url-mapping注解">4.2 URL Mapping注解</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span> <span class="comment">//对URL进行全局配置</span></span><br><span class="line">						 <span class="comment">//表示所有的url前缀前都有/test</span></span><br><span class="line">						 <span class="comment">//在类上使用表示全局配置，在方法上，表示不区分get/post请求</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testget&quot;)</span>	<span class="comment">//绑定Get请求</span></span><br><span class="line">    <span class="meta">@ResponseBody</span> <span class="comment">//直接向响应输出字符串数据，不跳转页面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello GetMapping&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/testget&quot;)</span> <span class="comment">//绑定Post请求</span></span><br><span class="line">    <span class="meta">@ResponseBody</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello PostMapping&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收请求参数">5. 接收请求参数</h3>
<ul>
<li>使用Controller方法参数接收</li>
<li>使用Java Bean接收数据</li>
</ul>
<h4 id="controller方法参数">5.1 Controller方法参数</h4>
<p>如，在某个html中，存在表单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/form1&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span> = <span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span> = <span class="string">&quot;passwd&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;submit&quot;</span> <span class="attr">value</span> = <span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>则在对应的controller中，就可以接收参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/form1&quot;)</span> <span class="comment">//绑定Post请求</span></span><br><span class="line"><span class="meta">@ResponseBody</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPost</span><span class="params">(String username, Long passwd)</span> </span>&#123;</span><br><span class="line">	System.out.println(username + <span class="string">&quot;:&quot;</span> + passwd);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有另一种形式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testget&quot;)</span>	<span class="comment">//绑定Get请求</span></span><br><span class="line"><span class="meta">@ResponseBody</span> </span><br><span class="line"><span class="comment">//@RequestParam(&quot;manager_name&quot;)通过注解显示声明，则方法参数名可以任取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(<span class="meta">@RequestParam(&quot;manager_name&quot;)</span> String ManagerName)</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ManagerName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用java-bean">5.2 使用Java Bean</h4>
<p>新建一个实体类User，对应的属性即为请求过来的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//变量名要与前端表单一致</span></span><br><span class="line">    String username;</span><br><span class="line">    Long passwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getPasswd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPasswd</span><span class="params">(Long passwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passwd = passwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置对应的Controller，此时通过user就能接收对应的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/post&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPost</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">	System.out.println(user.getUsername() + <span class="string">&quot;:&quot;</span> + user.getPasswd());</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;success!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若同时使用实体类和方法参数，则都会被注入对应的值</p>
<h4 id="日期类型转换">5.3 日期类型转换</h4>
<h5 id="方法参数中使用注解datetimeformat">5.3.1 方法参数中使用注解@DateTimeFormat</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/post&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPost</span><span class="params">(<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date createTime)</span> </span>&#123;</span><br><span class="line">    System.out.println(createTime);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="实体类中使用注解">5.3.2 实体类中使用注解</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    String username;</span><br><span class="line">    Long passwd;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span></span><br><span class="line">    Data createTime;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="新建转换类进行全局配置">5.3.3 新建转换类，进行全局配置</h5>
<p>转换类需要实现Converter&lt;S,T&gt;接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.imooc.springmvc.converter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sdf.parse(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>applicationContext.xml</code>中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    开启com.imooc.springmvc包下所有子包的注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.imooc.springmvc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    启用SpringMVC的注解开发模式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    将图片/js/css等静态资源排除，提高执行效率--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.imooc.springmvc.converter.DateConverter&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当同时存在全局配置和方法参数注解时，以小范围的优先，所以注解可以用来做一些特例的格式转换</p>
<h3 id="web应用中文乱码相关">6. Web应用中文乱码相关</h3>
<p>原因：Tomcat默认使用ISO-8859-1字符集，不包含中文</p>
<p>解决：将ISO-8859-1字符集转化为UTF-8</p>
<p>具体方案：</p>
<ul>
<li>Get请求乱码：server.xml增加URIEncoding属性</li>
<li>Post请求乱码：web.xml配置CharacterEncodingFilter</li>
<li>Response响应乱码：Spring配置StringHttpMessageConverter</li>
</ul>
<h4 id="get请求乱码">6.1 Get请求乱码</h4>
<p>在tomcat的安装路径<code>D:\Java\apache-tomcat-8.5.58\conf</code>中，找到server.xml文件</p>
<p>打开，找到Connector port=&quot;8080&quot;这部分，在最后添加<code>URIEncoding=&quot;UTF-8&quot;</code></p>
<p>Tomcat 8.0以后的版本可以不用配置，默认就是UTF-8</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="post请求乱码">6.2 Post请求乱码</h4>
<p>在web.xml中添加如下配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--要转换的字符集--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对所有url都进行拦截--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="response响应乱码">6.3 Response响应乱码</h4>
<p>在<code>applicationContext.xml</code>，修改<code>mvc:annotation-driven</code>为如下格式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;conversionService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html;charset=utf-8<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="响应输出结果">7. 响应输出结果</h3>
<ul>
<li><span class="citation" data-cites="ResponseBody">@ResponseBody</span> 产生响应文本</li>
<li>ModelAndView 利用模板引擎渲染输出</li>
</ul>
<h4 id="responsebody">7.1 <span class="citation" data-cites="ResponseBody">@ResponseBody</span></h4>
<p>直接产生相应体的数据，过程不设计任何视图</p>
<p>可产生标准字符串/JSON/XML等格式数据</p>
<p>可被StringHttpMessageConverter所影响</p>
<h4 id="modelandview对象输出">7.2 ModelAndView对象输出</h4>
<ul>
<li>ModelAndView对象是指”模型（数据）与视图（界面）“对象</li>
<li>通过ModelAndView可将包含数据对象与模板引擎进行绑定</li>
<li>SpringMVC中默认的View是JSP也可以配置其他模板引擎</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳转页面的方法</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/view&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/view.jsp&quot;</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;name&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>添加要跳转的view.jsp页面</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;Username: $&#123;name.username&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>访问<code>localhost:8080/view</code>就能看到显示效果</p>
<h3 id="modelandview">8. ModelAndView</h3>
<p><code>mav.addObject()</code>方法设置的属性默认存放在<strong>当前请求</strong>中</p>
<p>默认ModelAndView使用请求转发(forward)至页面</p>
<p>重定向使用<code>new ModelAndView(&quot;redirect:/index.jsp&quot;)</code>，当controller和view的联系不太紧密时，一般使用页面重定向</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/view.jsp&quot;</span>);</span><br><span class="line"><span class="comment">//也可以写成</span></span><br><span class="line">ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">mav.setViewName(<span class="string">&quot;/view.jsp&quot;</span>); </span><br><span class="line"><span class="comment">//若不包含/则是相对路径</span></span><br></pre></td></tr></table></figure>
<h3 id="整合freemarker">9. 整合Freemarker</h3>
<h4 id="引入依赖">9.1 引入依赖</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="启用freemarker模板引擎">9.2 启用Freemarker模板引擎</h4>
<p>在<code>applicationContext.xml</code>中添加bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ViewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        设置响应输出，并解决中文乱码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;contentType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;text/html;charset=utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--        指定Freemarker模板文件拓展名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.ftl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="配置freemarker参数">9.3 配置Freemarker参数</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;freemarkerConfig&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        设置模板保存目录--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateLoaderPath&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/ftl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        其他模板引擎设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;freemarkerSettings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        设置脚本与数据渲染时的字符集--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;defaultEncoding&quot;</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="测试freemarker">9.4 测试Freemarker</h4>
<p>新建FreemarkerController类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/fm&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreemarkerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;u&quot;</span>, user); <span class="comment">//u是别名</span></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面配置的路径<code>WEB-INF/ftl</code>下新建test.ftl，添加</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;$&#123;u.username&#125;&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<p>最后启动Tomcat，访问<code>localhost:8080/fm/test</code>就能看到运行效果</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
</search>
